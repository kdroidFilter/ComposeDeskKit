#import <Cocoa/Cocoa.h>
#import <objc/runtime.h>
#include <jni.h>
#include <math.h>

// Associated object keys
static const char kTitleBarConstraintsKey   = 0;
static const char kTitleBarHeightKey        = 1;
static const char kFullscreenObserverKey    = 2;
static const char kFullscreenButtonsKey     = 3;
static const char kOriginalButtonsParentKey = 4;
static const char kZoomResponderKey         = 5;
static const char kDragViewKey              = 6;

static const float kMinHeightForFullSize = 28.0f;
static const float kDefaultButtonOffset  = 20.0f;
static const float kFullscreenButtonsWidth = 80.0f;
static const float kFullscreenButtonsX     = 6.0f;

// _adjustWindowToScreen swizzle state
static BOOL sAdjustWindowSwizzled = NO;
static IMP sOriginalAdjustWindowToScreen = NULL;

// Forward declarations
static void applyConstraints(NSWindow *window, float height);
static void removeExistingConstraints(NSWindow *window);
static void installFullScreenButtons(NSWindow *window, float titleBarHeight);
static void removeFullScreenButtons(NSWindow *window);
static void updateFullScreenButtonsPosition(NSWindow *window);
static void ensureAdjustWindowSwizzle(NSWindow *window);
static void installZoomButtonResponder(NSWindow *window);
static void removeZoomButtonResponder(NSWindow *window);
static void ensureDragView(NSWindow *window);
static void removeDragView(NSWindow *window);

// ─── Fullscreen buttons container ───────────────────────────────────────────────

// Custom NSView that hosts replacement traffic-light buttons in the content view
// during fullscreen, mirroring JBR's AWTButtonsView.
// Buttons are hidden by default and revealed on hover (standard macOS fullscreen
// behavior — the menu bar and traffic lights only appear when the cursor moves
// to the top of the screen).
@interface NucleusButtonsView : NSView {
    NSTrackingArea *_hoverTrackingArea;
    BOOL _mouseInside;
}
@end

@implementation NucleusButtonsView

- (void)updateTrackingAreas {
    [super updateTrackingAreas];
    if (_hoverTrackingArea) {
        [self removeTrackingArea:_hoverTrackingArea];
    }
    // Use inVisibleRect so the tracking area auto-adjusts on resize/scroll
    _hoverTrackingArea = [[NSTrackingArea alloc]
        initWithRect:NSZeroRect
             options:(NSTrackingMouseEnteredAndExited |
                      NSTrackingActiveAlways |
                      NSTrackingInVisibleRect)
               owner:self
            userInfo:nil];
    [self addTrackingArea:_hoverTrackingArea];
}

- (void)mouseEntered:(NSEvent *)event {
    _mouseInside = YES;
    [NSAnimationContext runAnimationGroup:^(NSAnimationContext *ctx) {
        ctx.duration = 0.2;
        self.animator.alphaValue = 1.0;
    }];
}

- (void)mouseExited:(NSEvent *)event {
    _mouseInside = NO;
    [NSAnimationContext runAnimationGroup:^(NSAnimationContext *ctx) {
        ctx.duration = 0.3;
        self.animator.alphaValue = 0.0;
    }];
}

@end

// ─── Fullscreen observer ────────────────────────────────────────────────────────

@interface NucleusFSObserver : NSObject
@property (nonatomic, weak) NSWindow *window;
@end

@implementation NucleusFSObserver

- (instancetype)initWithWindow:(NSWindow *)window {
    self = [super init];
    if (self) {
        _window = window;
        NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];
        [nc addObserver:self selector:@selector(willEnterFullScreen:)
                   name:NSWindowWillEnterFullScreenNotification object:window];
        [nc addObserver:self selector:@selector(didEnterFullScreen:)
                   name:NSWindowDidEnterFullScreenNotification object:window];
        [nc addObserver:self selector:@selector(willExitFullScreen:)
                   name:NSWindowWillExitFullScreenNotification object:window];
        [nc addObserver:self selector:@selector(didExitFullScreen:)
                   name:NSWindowDidExitFullScreenNotification object:window];
    }
    return self;
}

- (void)dealloc {
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}

// About to enter fullscreen — remove constraints and drag view so macOS can animate cleanly
- (void)willEnterFullScreen:(NSNotification *)note {
    NSWindow *w = self.window;
    if (!w) return;

    removeDragView(w);
    removeExistingConstraints(w);
    [w setTitlebarAppearsTransparent:NO];
    [w setTitleVisibility:NSWindowTitleVisible];
    [w setMovable:YES];
}

// Finished entering fullscreen — install replacement buttons in the content view
- (void)didEnterFullScreen:(NSNotification *)note {
    NSWindow *w = self.window;
    if (!w) return;

    NSNumber *storedHeight = objc_getAssociatedObject(w, &kTitleBarHeightKey);
    float height = storedHeight ? [storedHeight floatValue] : kMinHeightForFullSize;

    installFullScreenButtons(w, height);
}

// About to exit fullscreen — remove replacement buttons
- (void)willExitFullScreen:(NSNotification *)note {
    NSWindow *w = self.window;
    if (!w) return;

    removeFullScreenButtons(w);
}

// Finished exiting fullscreen — restore the custom title bar
- (void)didExitFullScreen:(NSNotification *)note {
    NSWindow *w = self.window;
    if (!w) return;

    NSNumber *storedHeight = objc_getAssociatedObject(w, &kTitleBarHeightKey);
    if (!storedHeight) return;

    float height = [storedHeight floatValue];
    [w setTitlebarAppearsTransparent:YES];
    [w setTitleVisibility:NSWindowTitleHidden];
    [w setMovable:NO];
    applyConstraints(w, height);
}

@end

// ─── Zoom button responder ──────────────────────────────────────────────────────

// Temporarily re-enables window.movable when the mouse enters the zoom button,
// allowing macOS 15 window tiling to work even though movable is normally NO.
// Mirrors JBR's AWTWindowZoomButtonMouseResponder.
@interface NucleusZoomButtonResponder : NSObject
@property (nonatomic, weak) NSWindow *window;
@property (nonatomic, strong) NSTrackingArea *trackingArea;
@end

@implementation NucleusZoomButtonResponder

- (instancetype)initWithWindow:(NSWindow *)window {
    self = [super init];
    if (self) {
        _window = window;
        NSView *zoomButton = [window standardWindowButton:NSWindowZoomButton];
        if (zoomButton) {
            _trackingArea = [[NSTrackingArea alloc]
                initWithRect:zoomButton.bounds
                     options:(NSTrackingMouseEnteredAndExited | NSTrackingActiveInKeyWindow)
                       owner:self
                    userInfo:nil];
            [zoomButton addTrackingArea:_trackingArea];
        }
    }
    return self;
}

- (void)dealloc {
    if (_trackingArea) {
        NSView *zoomButton = _window ? [_window standardWindowButton:NSWindowZoomButton] : nil;
        if (zoomButton) {
            [zoomButton removeTrackingArea:_trackingArea];
        }
    }
}

- (void)mouseEntered:(NSEvent *)event {
    NSWindow *w = self.window;
    if (w && ![w isMovable]) {
        [w setMovable:YES];
    }
}

- (void)mouseExited:(NSEvent *)event {
    NSWindow *w = self.window;
    if (w && objc_getAssociatedObject(w, &kTitleBarHeightKey)) {
        [w setMovable:NO];
    }
}

@end

// ─── Native drag view ───────────────────────────────────────────────────────────

// Native NSView placed in the titlebar that handles window dragging via
// performWindowDragWithEvent: and double-click zoom/minimize.
// Mirrors JBR's AWTWindowDragView. All events are forwarded to the content
// view so AWT/Compose can process them normally.
@interface NucleusDragView : NSView {
    BOOL _dragging;
}
@end

@implementation NucleusDragView

- (BOOL)acceptsFirstMouse:(NSEvent *)event {
    return YES;
}

- (BOOL)shouldDelayWindowOrderingForEvent:(NSEvent *)event {
    return [[self.window contentView] shouldDelayWindowOrderingForEvent:event];
}

- (void)mouseDown:(NSEvent *)event {
    _dragging = NO;
    [[self.window contentView] mouseDown:event];
}

- (void)mouseUp:(NSEvent *)event {
    [[self.window contentView] mouseUp:event];
    // Double-click zoom is handled by Compose (MacOSTitleBar) so it can
    // check whether the event was consumed by an interactive component.
}

- (void)mouseDragged:(NSEvent *)event {
    if (!_dragging) {
        _dragging = YES;
        // Call performWindowDragWithEvent: with movable=NO, same as JBR.
        // Window tiling/snapping is handled by the _adjustWindowToScreen
        // swizzle which temporarily re-enables movable when macOS needs it.
        [self.window performWindowDragWithEvent:event];
        return;
    }
    [[self.window contentView] mouseDragged:event];
}

- (void)mouseMoved:(NSEvent *)event {
    [[self.window contentView] mouseMoved:event];
}

- (void)rightMouseDown:(NSEvent *)event {
    [[self.window contentView] rightMouseDown:event];
}

- (void)rightMouseUp:(NSEvent *)event {
    [[self.window contentView] rightMouseUp:event];
}

- (void)rightMouseDragged:(NSEvent *)event {
    [[self.window contentView] rightMouseDragged:event];
}

- (void)otherMouseDown:(NSEvent *)event {
    [[self.window contentView] otherMouseDown:event];
}

- (void)otherMouseUp:(NSEvent *)event {
    [[self.window contentView] otherMouseUp:event];
}

- (void)otherMouseDragged:(NSEvent *)event {
    [[self.window contentView] otherMouseDragged:event];
}

- (void)mouseEntered:(NSEvent *)event {
    [[self.window contentView] mouseEntered:event];
}

- (void)mouseExited:(NSEvent *)event {
    [[self.window contentView] mouseExited:event];
}

- (void)scrollWheel:(NSEvent *)event {
    [[self.window contentView] scrollWheel:event];
}

@end

// ─── Fullscreen button helpers ──────────────────────────────────────────────────

// Hides the native NSToolbarFullScreenWindow so the system hover toolbar
// doesn't overlap with our replacement buttons.
static void hideToolbarFullScreenWindow(void) {
    for (NSWindow *win in [[NSApplication sharedApplication] windows]) {
        if ([win isKindOfClass:NSClassFromString(@"NSToolbarFullScreenWindow")]) {
            [win.contentView setHidden:YES];
        }
    }
}

// Creates replacement traffic-light buttons in the content view,
// mirroring JBR's setWindowFullScreenControls.
static void installFullScreenButtons(NSWindow *window, float titleBarHeight) {
    // Don't double-install
    if (objc_getAssociatedObject(window, &kFullscreenButtonsKey)) return;

    // Capture the original buttons' parent (titlebar view) for frame reference
    NSView *origClose = [window standardWindowButton:NSWindowCloseButton];
    if (!origClose) return;
    objc_setAssociatedObject(window, &kOriginalButtonsParentKey,
                             origClose.superview, OBJC_ASSOCIATION_ASSIGN);

    NSRect closeRect = [[window standardWindowButton:NSWindowCloseButton] frame];
    NSRect miniRect  = [[window standardWindowButton:NSWindowMiniaturizeButton] frame];
    NSRect zoomRect  = [[window standardWindowButton:NSWindowZoomButton] frame];

    // Hide the native toolbar fullscreen window
    hideToolbarFullScreenWindow();

    // Create container
    NucleusButtonsView *container = [[NucleusButtonsView alloc] init];

    // Position the container (non-flipped: y=0 is at the bottom).
    // The container extends to the very top of the content view so
    // that its tracking area catches the cursor as it approaches the
    // top of the screen (standard macOS fullscreen reveal behavior).
    NSView *parent = window.contentView;
    CGFloat h = origClose.superview.frame.size.height;
    CGFloat buttonY = parent.frame.size.height - h - (titleBarHeight - h) / 2.0;
    CGFloat containerBottom = buttonY;
    CGFloat containerTop = parent.frame.size.height;
    [container setFrame:NSMakeRect(kFullscreenButtonsX, containerBottom,
                                   kFullscreenButtonsWidth - kFullscreenButtonsX,
                                   containerTop - containerBottom)];

    NSUInteger masks = [window styleMask];

    // Create replacement buttons with original frames
    NSButton *closeButton = [NSWindow standardWindowButton:NSWindowCloseButton forStyleMask:masks];
    [closeButton setFrame:closeRect];
    [container addSubview:closeButton];

    NSButton *miniButton = [NSWindow standardWindowButton:NSWindowMiniaturizeButton forStyleMask:masks];
    [miniButton setFrame:miniRect];
    [container addSubview:miniButton];

    NSButton *zoomButton = [NSWindow standardWindowButton:NSWindowZoomButton forStyleMask:masks];
    [zoomButton setFrame:zoomRect];
    [container addSubview:zoomButton];

    // Wire up button actions to the actual window
    [closeButton setTarget:window];
    [closeButton setAction:@selector(performClose:)];
    [miniButton setTarget:window];
    [miniButton setAction:@selector(performMiniaturize:)];
    [zoomButton setTarget:window];
    [zoomButton setAction:@selector(toggleFullScreen:)];

    // Start hidden — revealed on hover (standard macOS fullscreen behavior)
    [container setAlphaValue:0.0];

    [parent addSubview:container];

    objc_setAssociatedObject(window, &kFullscreenButtonsKey, container,
                             OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

// Removes the replacement fullscreen buttons.
static void removeFullScreenButtons(NSWindow *window) {
    NucleusButtonsView *container = objc_getAssociatedObject(window, &kFullscreenButtonsKey);
    if (!container) return;

    [container removeFromSuperview];
    objc_setAssociatedObject(window, &kFullscreenButtonsKey, nil,
                             OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    objc_setAssociatedObject(window, &kOriginalButtonsParentKey, nil,
                             OBJC_ASSOCIATION_ASSIGN);
}

// Repositions the fullscreen button container (called from layout passes).
// Same formula as JBR's updateFullScreenButtons.
static void updateFullScreenButtonsPosition(NSWindow *window) {
    NucleusButtonsView *container = objc_getAssociatedObject(window, &kFullscreenButtonsKey);
    if (!container) return;

    NSView *origParent = objc_getAssociatedObject(window, &kOriginalButtonsParentKey);
    NSView *parent = window.contentView;
    if (!parent) return;

    NSNumber *storedHeight = objc_getAssociatedObject(window, &kTitleBarHeightKey);
    float titleBarHeight = storedHeight ? [storedHeight floatValue] : kMinHeightForFullSize;

    CGFloat h = origParent ? origParent.frame.size.height : kMinHeightForFullSize;
    CGFloat buttonY = parent.frame.size.height - h - (titleBarHeight - h) / 2.0;
    CGFloat containerBottom = buttonY;
    CGFloat containerTop = parent.frame.size.height;
    [container setFrame:NSMakeRect(kFullscreenButtonsX, containerBottom,
                                   kFullscreenButtonsWidth - kFullscreenButtonsX,
                                   containerTop - containerBottom)];
}

// ─── _adjustWindowToScreen swizzle ──────────────────────────────────────────────

// macOS calls _adjustWindowToScreen for window snapping/tiling near screen edges.
// Since we set movable=NO, this callback is blocked. Override to temporarily
// re-enable movable (mirrors JBR's AWTWindow_Normal._adjustWindowToScreen).
static void nucleus_adjustWindowToScreen(id self, SEL _cmd) {
    NSNumber *storedHeight = objc_getAssociatedObject(self, &kTitleBarHeightKey);
    BOOL needsRestore = storedHeight && ![(NSWindow *)self isMovable];

    if (needsRestore) {
        [(NSWindow *)self setMovable:YES];
    }

    if (sOriginalAdjustWindowToScreen) {
        ((void (*)(id, SEL))sOriginalAdjustWindowToScreen)(self, _cmd);
    }

    updateFullScreenButtonsPosition((NSWindow *)self);

    if (needsRestore) {
        [(NSWindow *)self setMovable:NO];
    }
}

static void ensureAdjustWindowSwizzle(NSWindow *window) {
    if (sAdjustWindowSwizzled) return;
    sAdjustWindowSwizzled = YES;

    Class cls = object_getClass(window);
    SEL sel = NSSelectorFromString(@"_adjustWindowToScreen");
    Method method = class_getInstanceMethod(cls, sel);
    if (method) {
        sOriginalAdjustWindowToScreen = method_getImplementation(method);
        method_setImplementation(method, (IMP)nucleus_adjustWindowToScreen);
    }
}

// ─── Zoom button responder helpers ──────────────────────────────────────────────

static void installZoomButtonResponder(NSWindow *window) {
    if (objc_getAssociatedObject(window, &kZoomResponderKey)) return;

    NucleusZoomButtonResponder *responder =
        [[NucleusZoomButtonResponder alloc] initWithWindow:window];
    objc_setAssociatedObject(window, &kZoomResponderKey, responder,
                             OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

static void removeZoomButtonResponder(NSWindow *window) {
    objc_setAssociatedObject(window, &kZoomResponderKey, nil,
                             OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

// ─── Drag view helpers ──────────────────────────────────────────────────────────

// Installs the drag view once in the titlebar. Subsequent calls are no-ops.
// The drag view persists across constraint updates so an in-progress drag
// is never interrupted by Compose layout passes.
static void ensureDragView(NSWindow *window) {
    if (objc_getAssociatedObject(window, &kDragViewKey)) return;

    NSView *closeBtn = [window standardWindowButton:NSWindowCloseButton];
    if (!closeBtn) return;
    NSView *titlebar = closeBtn.superview;
    if (!titlebar) return;

    NucleusDragView *dragView = [[NucleusDragView alloc] init];
    [titlebar addSubview:dragView positioned:NSWindowBelow relativeTo:closeBtn];
    objc_setAssociatedObject(window, &kDragViewKey, dragView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

static void removeDragView(NSWindow *window) {
    NucleusDragView *dragView = objc_getAssociatedObject(window, &kDragViewKey);
    if (!dragView) return;
    [dragView removeFromSuperview];
    objc_setAssociatedObject(window, &kDragViewKey, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

// ─── Constraint helpers ─────────────────────────────────────────────────────────

static void removeExistingConstraints(NSWindow *window) {
    NSMutableArray *existing = objc_getAssociatedObject(window, &kTitleBarConstraintsKey);
    if (!existing) return;

    [NSLayoutConstraint deactivateConstraints:existing];
    objc_setAssociatedObject(window, &kTitleBarConstraintsKey, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);

    // Note: drag view is NOT removed here — it persists across constraint
    // updates so an in-progress drag is never interrupted.

    // Restore autoresizing mask so AppKit can manage layout again
    NSView *closeBtn = [window standardWindowButton:NSWindowCloseButton];
    if (!closeBtn) return;
    NSView *titlebar          = closeBtn.superview;
    NSView *titlebarContainer = titlebar ? titlebar.superview : nil;

    if (titlebarContainer) {
        titlebarContainer.translatesAutoresizingMaskIntoConstraints = YES;
    }
    if (titlebar) {
        titlebar.translatesAutoresizingMaskIntoConstraints = YES;
    }
    closeBtn.translatesAutoresizingMaskIntoConstraints = YES;
    NSView *miniBtn = [window standardWindowButton:NSWindowMiniaturizeButton];
    NSView *zoomBtn = [window standardWindowButton:NSWindowZoomButton];
    if (miniBtn) miniBtn.translatesAutoresizingMaskIntoConstraints = YES;
    if (zoomBtn) zoomBtn.translatesAutoresizingMaskIntoConstraints = YES;
}

static void applyConstraints(NSWindow *window, float height) {
    NSView *closeBtn = [window standardWindowButton:NSWindowCloseButton];
    NSView *miniBtn  = [window standardWindowButton:NSWindowMiniaturizeButton];
    NSView *zoomBtn  = [window standardWindowButton:NSWindowZoomButton];
    if (!closeBtn || !miniBtn || !zoomBtn) return;

    NSView *titlebar          = closeBtn.superview;
    NSView *titlebarContainer = titlebar ? titlebar.superview : nil;
    NSView *themeFrame        = titlebarContainer ? titlebarContainer.superview : nil;
    if (!themeFrame) return;

    removeExistingConstraints(window);

    NSMutableArray *constraints = [NSMutableArray array];

    titlebarContainer.translatesAutoresizingMaskIntoConstraints = NO;
    [constraints addObjectsFromArray:@[
        [titlebarContainer.leftAnchor  constraintEqualToAnchor:themeFrame.leftAnchor],
        [titlebarContainer.widthAnchor constraintEqualToAnchor:themeFrame.widthAnchor],
        [titlebarContainer.topAnchor   constraintEqualToAnchor:themeFrame.topAnchor],
        [titlebarContainer.heightAnchor constraintEqualToConstant:height],
    ]];

    titlebar.translatesAutoresizingMaskIntoConstraints = NO;
    [constraints addObjectsFromArray:@[
        [titlebar.leftAnchor   constraintEqualToAnchor:titlebarContainer.leftAnchor],
        [titlebar.rightAnchor  constraintEqualToAnchor:titlebarContainer.rightAnchor],
        [titlebar.topAnchor    constraintEqualToAnchor:titlebarContainer.topAnchor],
        [titlebar.bottomAnchor constraintEqualToAnchor:titlebarContainer.bottomAnchor],
    ]];

    // Add constraints for the drag view (installed once by ensureDragView)
    NucleusDragView *dragView = objc_getAssociatedObject(window, &kDragViewKey);
    if (dragView) {
        dragView.translatesAutoresizingMaskIntoConstraints = NO;
        [constraints addObjectsFromArray:@[
            [dragView.leftAnchor   constraintEqualToAnchor:titlebarContainer.leftAnchor],
            [dragView.rightAnchor  constraintEqualToAnchor:titlebarContainer.rightAnchor],
            [dragView.topAnchor    constraintEqualToAnchor:titlebarContainer.topAnchor],
            [dragView.bottomAnchor constraintEqualToAnchor:titlebarContainer.bottomAnchor],
        ]];
    }

    float shrinkFactor = fminf(height / kMinHeightForFullSize, 1.0f);
    float offset       = shrinkFactor * kDefaultButtonOffset;

    NSArray *buttons = @[closeBtn, miniBtn, zoomBtn];
    [buttons enumerateObjectsUsingBlock:^(NSView *btn, NSUInteger idx, BOOL *stop) {
        btn.translatesAutoresizingMaskIntoConstraints = NO;
        [constraints addObjectsFromArray:@[
            [btn.widthAnchor  constraintLessThanOrEqualToAnchor:titlebarContainer.heightAnchor
                                                     multiplier:0.5],
            [btn.heightAnchor constraintEqualToAnchor:btn.widthAnchor
                                           multiplier:14.0 / 12.0
                                             constant:-2.0],
            [btn.centerYAnchor constraintEqualToAnchor:titlebarContainer.centerYAnchor],
            [btn.centerXAnchor constraintEqualToAnchor:titlebarContainer.leftAnchor
                                              constant:(height / 2.0f + idx * offset)],
        ]];
    }];

    [NSLayoutConstraint activateConstraints:constraints];
    objc_setAssociatedObject(window, &kTitleBarConstraintsKey, constraints,
                             OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

static void ensureFullscreenObserver(NSWindow *window) {
    NucleusFSObserver *existing = objc_getAssociatedObject(window, &kFullscreenObserverKey);
    if (existing) return;

    NucleusFSObserver *observer = [[NucleusFSObserver alloc] initWithWindow:window];
    objc_setAssociatedObject(window, &kFullscreenObserverKey, observer,
                             OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

static void removeFullscreenObserver(NSWindow *window) {
    objc_setAssociatedObject(window, &kFullscreenObserverKey, nil,
                             OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

// ─── JNI exports ────────────────────────────────────────────────────────────────

JNIEXPORT jfloat JNICALL
Java_io_github_kdroidfilter_nucleus_window_utils_macos_JniMacTitleBarBridge_nativeApplyTitleBar(
    JNIEnv *env, jclass clazz, jlong nsWindowPtr, jfloat heightPt) {

    if (nsWindowPtr == 0) return 0.0f;

    float shrink    = fminf(heightPt / kMinHeightForFullSize, 1.0f);
    float btnOffset = shrink * kDefaultButtonOffset;
    float leftInset = heightPt + 2.0f * btnOffset;

    NSWindow *window = (__bridge NSWindow *)(void *)nsWindowPtr;
    float capturedHeight = heightPt;

    dispatch_async(dispatch_get_main_queue(), ^{
        @autoreleasepool {
            // Store the desired height for fullscreen restore
            objc_setAssociatedObject(window, &kTitleBarHeightKey,
                                     @(capturedHeight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);

            ensureFullscreenObserver(window);
            ensureAdjustWindowSwizzle(window);
            installZoomButtonResponder(window);

            if ((window.styleMask & NSWindowStyleMaskFullScreen) != 0) {
                // In fullscreen: update replacement button positions
                updateFullScreenButtonsPosition(window);
                return;
            }

            [window setTitlebarAppearsTransparent:YES];
            [window setTitleVisibility:NSWindowTitleHidden];
            [window setMovable:NO];

            ensureDragView(window);
            applyConstraints(window, capturedHeight);
        }
    });

    return leftInset;
}

JNIEXPORT void JNICALL
Java_io_github_kdroidfilter_nucleus_window_utils_macos_JniMacTitleBarBridge_nativeResetTitleBar(
    JNIEnv *env, jclass clazz, jlong nsWindowPtr) {

    if (nsWindowPtr == 0) return;
    NSWindow *window = (__bridge NSWindow *)(void *)nsWindowPtr;
    dispatch_async(dispatch_get_main_queue(), ^{
        @autoreleasepool {
            removeFullScreenButtons(window);
            removeFullscreenObserver(window);
            removeZoomButtonResponder(window);
            removeDragView(window);
            removeExistingConstraints(window);
            objc_setAssociatedObject(window, &kTitleBarHeightKey, nil,
                                     OBJC_ASSOCIATION_RETAIN_NONATOMIC);
            [window setTitlebarAppearsTransparent:NO];
            [window setTitleVisibility:NSWindowTitleVisible];
            [window setMovable:YES];
        }
    });
}

// Called from Kotlin on each layout pass during fullscreen to keep
// the replacement buttons positioned correctly.
JNIEXPORT void JNICALL
Java_io_github_kdroidfilter_nucleus_window_utils_macos_JniMacTitleBarBridge_nativeUpdateFullScreenButtons(
    JNIEnv *env, jclass clazz, jlong nsWindowPtr) {

    if (nsWindowPtr == 0) return;
    NSWindow *window = (__bridge NSWindow *)(void *)nsWindowPtr;
    dispatch_async(dispatch_get_main_queue(), ^{
        @autoreleasepool {
            updateFullScreenButtonsPosition(window);
        }
    });
}

// Performs the macOS title bar double-click action (zoom or minimize)
// respecting the user's system preference (AppleActionOnDoubleClick).
// Called from Compose when an unconsumed double-click is detected.
JNIEXPORT void JNICALL
Java_io_github_kdroidfilter_nucleus_window_utils_macos_JniMacTitleBarBridge_nativePerformTitleBarDoubleClickAction(
    JNIEnv *env, jclass clazz, jlong nsWindowPtr) {

    if (nsWindowPtr == 0) return;
    NSWindow *window = (__bridge NSWindow *)(void *)nsWindowPtr;
    dispatch_async(dispatch_get_main_queue(), ^{
        @autoreleasepool {
            NSString *action = [[NSUserDefaults standardUserDefaults]
                stringForKey:@"AppleActionOnDoubleClick"];
            if (action && [action caseInsensitiveCompare:@"Minimize"] == NSOrderedSame) {
                [window performMiniaturize:nil];
            } else if (!action || [action caseInsensitiveCompare:@"None"] != NSOrderedSame) {
                [window performZoom:nil];
            }
        }
    });
}
